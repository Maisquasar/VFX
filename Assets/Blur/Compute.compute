// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

int _TextureWidth;
int _TextureHeight;

Texture2D _Source;
RWTexture2D<float4> _Destination;

groupshared float4 ldr[64];

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_GroupThreadID, uint3 groupId : SV_GroupID)
{
    #if 1
    uint lds_idx = id.x + id.y * 8;

    int2 outPixelCoord = groupId.xy * 4;
    outPixelCoord += int2(id.xy - 2);

    outPixelCoord.x = clamp(outPixelCoord.x, 0, _TextureWidth - 1);
    outPixelCoord.y = clamp(outPixelCoord.y, 0, _TextureHeight - 1);

    float4 sourcePixel = _Source.Load(int3(outPixelCoord, 0));
    ldr[lds_idx] = sourcePixel;

    GroupMemoryBarrierWithGroupSync();

    // 16/64
    if (id.x > 1 && id.x < 6 && id.y > 1 && id.y < 6)
    {
        float4 sum = float4(0, 0, 0, 0);
        for (int i = id.x - 2; i <= id.x + 2; i++)
        {
            for (int j = id.y - 2; j <= id.y + 2; j++)
            {
                sum += ldr[i + j * 8];
            }
        }
        sum /= 25;
        _Destination[outPixelCoord] = sum;
    #else

    uint lds_idx = id.x + id.y * 8;

    int2 outPixelCoord = groupId.xy * 4 + int2(id.xy - 2);
    outPixelCoord = clamp(outPixelCoord, int2(0, 0), int2(_TextureWidth - 1, _TextureHeight - 1));

    ldr[lds_idx] = _Source.Load(int3(outPixelCoord, 0));

    GroupMemoryBarrierWithGroupSync();

    if (all(id.xy > 1 && id.xy < 6))
    {
        float4 sum = 0;

        float4 temp = 0;
        [unroll]
        for (int i = -2; i <= 2; i++)
        {
            float w = (i == 0) ? 0.4 : (abs(i) == 1) ? 0.24 : 0.06;
            temp += ldr[lds_idx + i] * w;
        }

        _Destination[outPixelCoord] = temp;
    #endif
    }
}
